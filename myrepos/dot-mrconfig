[DEFAULT]

lib =
  # Provide for `mr git ...`
  git() {
    command git --no-pager "$@"
  }
  # Provide for `mr gh ...`
  gh() {
    env GH_PAGER= gh "$@"
  }

# Skip if the repository is a fork, as indicated by an upstream URL.
# skip = git -C "$MR_REPO" config get --local remote.upstream.url >& /dev/null

# Skip if the repository has been archived on GitHub.
# skip = [[ "$( git -C "$MR_REPO" config get --local remote.origin.gh-archived )" == true ]]

edit = if [[ "$#" -gt 0 ]]; then vim "$@" else vim . fi

# TODO: Figure out how to tell Tilix to open a tab for Linux.
tab =
  if [[ "$( uname -s )" = Darwin ]]; then
    osascript -e 'tell application "iTerm2" to tell current window' \
              -e '  create tab with default profile' \
              -e '  tell current session to write text "builtin cd '"'$MR_REPO'"'; '"$@"'"' \
              -e 'end tell'
    exit
  fi
  error "unsupported on $( uname -s )"

# Quick access to the git(1) and gh(1) commands.
git_git = git "$@"
git_gh  = gh "$@"

# Some of the more common git(1) commands.
git_branch = git branch "$@"
git_gc     = git gc "$@"
git_switch = git switch "$@"
git_tags   = git tag "$@"

git_checkoutdefaultbranch = git switch "$( git default-branch )"
git_defaultbranch         = git default-branch
git_mergedefaultbranch    = git merge "$( git default-branch )"
git_nondefaultbranch      = git branch | awk '( $1 == "*" ) { print $2 }' | { grep -v "$( git default-branch )" || true; }

git_setarchivedflag =
  git config set --local remote.origin.gh-archived "$( gh repo view --json isArchived --template '{{ .isArchived }}' )"
  git config get --local remote.origin.gh-archived

# Stash any uncommitted changes, switch to the default branch, and pull the latest changes.
git_baseline =
  git stash push --all --quiet --message 'mr: Stashed uncommitted changes before baseline'
  git switch --quiet "$( git symbolic-ref refs/remotes/origin/HEAD | sed -e 's,^refs/remotes/origin/,,' )"
  git pull --quiet

git_stalebranches =
  gh api repos/{owner}/{repo}/branches --paginate --jq '.[].name' |
    xargs -I % -P 8 gh api repos/{owner}/{repo}/branches/% --jq '
      {
        Branch:  .name,
        Commit:  .commit.sha[0:7],
        Date:    .commit.commit.author.date,
        Message: ( .commit.commit.message | split("\n") | .[0] ),
        Author:  .commit.commit.author.name
      }
    ' |
    mlr --j2p sort -f 'Date' then cut -f 'Branch,Commit,Date,Author,Message' -o

# Print the branch information only if there is more than one local branch (assumes a single branch is the default).
git_localbranches =
  branches="$( git branch -vv )"
  if [[ $( wc -l <<< "$branches" ) -gt 1 ]]; then
    echo "$branches"
  fi

# Print any branches that are tracking branches no longer present on the remote.
git_missingbranches =
  git branch -vv | grep -F ': gone]' || true

git_latestrelease =
  { gh api 'repos/{owner}/{repo}/releases/latest' 2> /dev/null || true; } | jq -r '.tag_name // empty'

include = cat ~/.mrconfig.d/*.conf 2>/dev/null || :

[ALIAS]
cd = checkoutdefaultbranch
db = defaultbranch
lb = localbranches
md = mergedefaultbranch

[.dotfiles]
checkout = git clone 'https://github.com/sirhc/dotfiles.git' '.dotfiles'
chain    = true

[.vim]
checkout = git clone 'https://github.com/sirhc/vim-profile.git' '.vim'
chain    = true
