# vim: ft=zsh nospell

typeset -aU path manpath fpath

path=(/usr/local/bin /usr/local/sbin)
path=($path /usr/bin)
[[ ! -L /bin ]] && path=($path /bin) # /bin and /sbin are symlinks on Fedora
path=($path /usr/sbin)
[[ ! -L /sbin ]] && path=($path /sbin)
[[ -d /opt/homebrew/bin ]] && path=(/opt/homebrew/bin $path)

path=(
    ~/bin
    # This is a habit from a time when my home directory was on NFS and shared on
    # multiple types of systems. It still comes in handy when I want to keep
    # binaries in `~/bin`, which I tend to sync between systems.
    ~/bin/${OSTYPE/[0-9]*/}-${CPUTYPE} # e.g., linux-gnu-x86_64, darwin-arm64
    ~/.local/bin
    $path
)

[[ -d /opt/homebrew/share/zsh/site-functions ]] && fpath=(/opt/homebrew/share/zsh/site-functions $fpath)
[[ -d ~/.zshrc.d/functions ]] && fpath=(~/.zshrc.d/functions $fpath) # in front, to override packaged functions

# See zshparam(1).
HISTFILE=~/.zsh_history
HISTORY_IGNORE='(exit|reset|clear|cd|cd ..|cd..|ls)'
HISTSIZE=1000000    # the number of items for the internal history list
LISTMAX=0           # only prompt if the list will scroll
#REPORTMEMORY=102400 # report on commands exceeding 100 MiB RSS
REPORTTIME=5        # report on commands exceeding 5 s exec time
SAVEHIST=1000000    # maximum number of items for the history file
TIMEFMT="${TIMEFMT} %Mk max rss"

# See zshoptions(1).
setopt EXTENDED_GLOB           # use #, ~, ^ for filename generation
setopt EXTENDED_HISTORY        # record command start time
setopt HIST_FCNTL_LOCK         # use fcntl to lock history file
setopt HIST_IGNORE_ALL_DUPS    # do not add duplicate command to history
setopt HIST_IGNORE_SPACE       # do not add commands with leading space to history
setopt HIST_NO_STORE           # do not store the `history` command
setopt HIST_REDUCE_BLANKS      # remove superfluous blanks
setopt HIST_SAVE_NO_DUPS       # do not save duplicate commands
setopt HIST_VERIFY             # confirm history expansion before executing
setopt INC_APPEND_HISTORY_TIME # append command to history file immediately after execution
setopt INTERACTIVE_COMMENTS    # allow comments even in interactive shells

unsetopt CASE_GLOB # case-insensitive file globbing
unsetopt NOMATCH   # leave unmatched patterns alone in arg list

export ANSIBLE_COW_SELECTION=random
export AWS_PAGER=
export BC_ENV_ARGS="-lq $HOME/.bcrc"
export CLICOLOR=1 # colorize ls(1) on Darwin
export EDITOR=vim
export GREP=egrep
export LESS='-# 4 -c -I -j 10 -M -R -S'
export MAN_POSIXLY_CORRECT=1
export NPM_PACKAGES="$HOME/.local"
export PAGER=less
export PERLDOC_PAGER=less
export RSYNC_RSH=ssh
export TZ=US/Pacific
export UNZIP=-qq

for _env in ~/.*env(/); do
    [[ -d $_env/bin ]] && path=($_env/bin $path)
    [[ -d $_env/shims ]] && path=($_env/shims $path)
done
unset _env

autoload -U compinit && compinit

zstyle ':completion:*' accept-exact-dirs true
zstyle ':completion:*' matcher-list 'm:{a-zA-Z-_}={A-Za-z_-}' 'r:|=*' 'l:|=* r:|=*'
zstyle ':completion:*' menu select

autoload -U up-line-or-beginning-search
autoload -U down-line-or-beginning-search
zle -N up-line-or-beginning-search
zle -N down-line-or-beginning-search
bindkey "${terminfo[kcuu1]}" up-line-or-beginning-search   # ${key[Up]} doesn't work
bindkey "${terminfo[kcud1]}" down-line-or-beginning-search # ditto ${key[Down]}

bindkey ' ' magic-space

# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
    source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ -f ~/.p10k.zsh ]] && source ~/.p10k.zsh
[[ -f ~/.zshrc.d/powerlevel10k/powerlevel10k.zsh-theme ]] && source ~/.zshrc.d/powerlevel10k/powerlevel10k.zsh-theme

# Source files in my autoload directory. This is where I tend to keep aliases
# and functions, which should always be loaded (unlike plugins, which are
# loaded selectively).

if [[ -d ~/.zshrc.d/autoload ]]; then
    for _autoload_file in ~/.zshrc.d/autoload/*(.); do
        source $_autoload_file
    done
    unset _autoload_file
fi

# Rudimentary plugin autoloading (à la Vim), but serves my purposes at the moment.

for _plugin in ~/.zshrc.d/plugins/*/*.plugin.zsh; do
    source $_plugin
done
unset _plugin

_set_terminal_title() {
    if [[ $LC_TERMINAL == iTerm2 ]]; then
        print -Pn "\e]2;%n@%M\a" # user@host:path (title)
        print -Pn "\e]1;%~\a"    # user@host:path (tab)
    else
        print -Pn "\e]2;%n@%M:%~\a" # user@host:path
    fi
}

autoload -Uz add-zsh-hook
add-zsh-hook precmd _set_terminal_title

# From <https://github.com/ohmyzsh/ohmyzsh/blob/master/lib/completion.zsh>.
expand-or-complete-with-dots() {
  local dots='%F{red}…%f'
  printf '\e[?7l%s\e[?7h' "${(%)dots}"
  zle expand-or-complete
  zle redisplay
}
zle -N expand-or-complete-with-dots
bindkey -M emacs "^I" expand-or-complete-with-dots
bindkey -M viins "^I" expand-or-complete-with-dots
bindkey -M vicmd "^I" expand-or-complete-with-dots
